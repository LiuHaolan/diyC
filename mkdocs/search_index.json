{
    "docs": [
        {
            "location": "/",
            "text": "Linux containers from scratch - diyC\n#\n\n\nLinux containers exist for a while and are now a mainstream\ntopic. This is an introduction on how they are created and what they\nactually are made of. If you want to see the code then head directly\nto \nthe github repo\n otherwise read on\nthe topic you are interested in.\n\n\n\n\nNote\n\n\nAny suggestions or comments are welcome please don't hesitate\nand \nfile an issue on github\n.\n\n\n\n\nWhat is a Linux container\n#\n\n\nContainers in some form exist for quite while even though \nwe don't\nallways think of them as containers\n. \n\n\n\n\nLinux container to put it simply it is a usuall Linux process (or\ngroup of processes) with a limited (altered) view of the system.\n\n\n\n\nIt is achieved by utilizing\n\nOperating system level virtualization\n.\n\n\nKernel features and other bits needed\n#\n\n\n\n\nLinux namespaces\n\n\nLinux cgroups\n\n\nNetworking\n\n\nImages and containers\n\n\nGlueing it together\n\n\n\n\nWhat is diyC\n#\n\n\nIt is a simple educational Linux container runtime. It is\nintentionally simple and leaves a lot of stuff out. It is\na \nsingle C file\n\nof roughly 500 lines including comments showing the core features of\nthe Linux used to build containers. It includes also the creation of a\ncontainer from an image to clarify how images and containers are\nrelated.\n\n\nnsexec\n#\n\n\nPart of the project is also\na \nnsexec\n binary\n \nwhich is is a very simple program that executes a local (host) command\nin Linux namespaces. See \nnsexec --help\n to see what namespaces are\navailable. Usage is very simple \nsudo ./nsexec -pnu myhost bash\n will\nstart a new bash in new pid, network and UTS namespace.",
            "title": "Home"
        },
        {
            "location": "/#linux-containers-from-scratch-diyc",
            "text": "Linux containers exist for a while and are now a mainstream\ntopic. This is an introduction on how they are created and what they\nactually are made of. If you want to see the code then head directly\nto  the github repo  otherwise read on\nthe topic you are interested in.   Note  Any suggestions or comments are welcome please don't hesitate\nand  file an issue on github .",
            "title": "Linux containers from scratch - diyC"
        },
        {
            "location": "/#what-is-a-linux-container",
            "text": "Containers in some form exist for quite while even though  we don't\nallways think of them as containers .    Linux container to put it simply it is a usuall Linux process (or\ngroup of processes) with a limited (altered) view of the system.   It is achieved by utilizing Operating system level virtualization .",
            "title": "What is a Linux container"
        },
        {
            "location": "/#kernel-features-and-other-bits-needed",
            "text": "Linux namespaces  Linux cgroups  Networking  Images and containers  Glueing it together",
            "title": "Kernel features and other bits needed"
        },
        {
            "location": "/#what-is-diyc",
            "text": "It is a simple educational Linux container runtime. It is\nintentionally simple and leaves a lot of stuff out. It is\na  single C file \nof roughly 500 lines including comments showing the core features of\nthe Linux used to build containers. It includes also the creation of a\ncontainer from an image to clarify how images and containers are\nrelated.",
            "title": "What is diyC"
        },
        {
            "location": "/#nsexec",
            "text": "Part of the project is also\na  nsexec  binary  \nwhich is is a very simple program that executes a local (host) command\nin Linux namespaces. See  nsexec --help  to see what namespaces are\navailable. Usage is very simple  sudo ./nsexec -pnu myhost bash  will\nstart a new bash in new pid, network and UTS namespace.",
            "title": "nsexec"
        },
        {
            "location": "/diyc/install/",
            "text": "Getting started\n#\n\n\n\n\niptables\n\n\ndiyC plays with iptables to get the routing and isolation running so if\nyou have your own iptables rules make sure to save them before doing\nanything else. Just \nsudo iptables-save\n and \nsudo iptables-restore\n to\nrecover them in case something goes awry.\n\n\n\n\nPrerequisites\n#\n\n\nThis is a educational piece of software and has not been tested on\nmany systems yet, to give it a go make sure you have the following:\n\n\n\n\nrecent Linux kernel supporting needed namespaces and cgroups\n\n\noverlayfs \n\n\nip tool (\niproute2 package\n)\n\n\niptables \n\n\ngcc\n\n\nmake\n\n\nbash\n\n\n\n\nOverlayfs is in the mainline kernel so it everything should be\nstraight forward it was merged in version 3.18 but has been improved a\nlot so you should aim for kernel 4.x and in that case you have all the\nnamespaces and cgroups too.\n\n\n\n\nKernel configuration\n\n\nKernel needs to be configured to support following namespaces\nPID, mount, network and UTS, cgroups are needed as well. Most of the\nGNU/Linux distros have this support enabled by default.\n\n\n\n\nInstallation\n#\n\n\n\n\n\n\nmake setup\n\n\nIt creates the necessary directory structure as well as prepares the\nnetworking part like iptables rules, bridge (diyc0) and so on. To\nremove the networking bits like bridge and iptables rules run \nmake\nnet-clean\n which removes them all.\n\n\n\n\n\n\nmake\n\n\nBuilds the runtime.\n\n\n\n\n\n\nDone\n\n\n\n\n\n\nPreparing images\n#\n\n\nThe image import and creation is not present but because images are\njust \nTARBALLS\n there is no need for anything fancy.\n\n\nCreating the tarball using docker\n#\n\n\nUsing docker is the most straightforward. \ndocker pull\n the image you\nwant, spin it up by \ndocker run -ti <image> <command>\n and in\ndifferent terminal do \ndocker export <container> > myimage.tar\n. You\nhave the tarball ready.\n\n\nInstalling image\n#\n\n\nmake setup\n creates an \nimages\n subdirectory so \nmkdir\nimages/myimage\n followed by \ntar -xf myimage.tar -C images/myimage/\n\nshould do the trick. The relation of images and containers is\ndescribed in a section of it's\nown. \nImages and Containers\n.\n\n\n\n\nExample\n\n\nSee \nhow to run a container",
            "title": "Installation"
        },
        {
            "location": "/diyc/install/#getting-started",
            "text": "iptables  diyC plays with iptables to get the routing and isolation running so if\nyou have your own iptables rules make sure to save them before doing\nanything else. Just  sudo iptables-save  and  sudo iptables-restore  to\nrecover them in case something goes awry.",
            "title": "Getting started"
        },
        {
            "location": "/diyc/install/#prerequisites",
            "text": "This is a educational piece of software and has not been tested on\nmany systems yet, to give it a go make sure you have the following:   recent Linux kernel supporting needed namespaces and cgroups  overlayfs   ip tool ( iproute2 package )  iptables   gcc  make  bash   Overlayfs is in the mainline kernel so it everything should be\nstraight forward it was merged in version 3.18 but has been improved a\nlot so you should aim for kernel 4.x and in that case you have all the\nnamespaces and cgroups too.   Kernel configuration  Kernel needs to be configured to support following namespaces\nPID, mount, network and UTS, cgroups are needed as well. Most of the\nGNU/Linux distros have this support enabled by default.",
            "title": "Prerequisites"
        },
        {
            "location": "/diyc/install/#installation",
            "text": "make setup  It creates the necessary directory structure as well as prepares the\nnetworking part like iptables rules, bridge (diyc0) and so on. To\nremove the networking bits like bridge and iptables rules run  make\nnet-clean  which removes them all.    make  Builds the runtime.    Done",
            "title": "Installation"
        },
        {
            "location": "/diyc/install/#preparing-images",
            "text": "The image import and creation is not present but because images are\njust  TARBALLS  there is no need for anything fancy.",
            "title": "Preparing images"
        },
        {
            "location": "/diyc/install/#creating-the-tarball-using-docker",
            "text": "Using docker is the most straightforward.  docker pull  the image you\nwant, spin it up by  docker run -ti <image> <command>  and in\ndifferent terminal do  docker export <container> > myimage.tar . You\nhave the tarball ready.",
            "title": "Creating the tarball using docker"
        },
        {
            "location": "/diyc/install/#installing-image",
            "text": "make setup  creates an  images  subdirectory so  mkdir\nimages/myimage  followed by  tar -xf myimage.tar -C images/myimage/ \nshould do the trick. The relation of images and containers is\ndescribed in a section of it's\nown.  Images and Containers .   Example  See  how to run a container",
            "title": "Installing image"
        },
        {
            "location": "/diyc/usage/",
            "text": "Usage\n#\n\n\n    diyc [hv][-m NUMBER] [-ip IPV4 ADDRESS] <NAME> <IMAGE> <CMD>\n\n    -h, --help           print the help\n\n    -i, --ip             ip address of the container, if not set then host\n                         network is used. It must be in the 172.16.0/16 network\n                         as the bridge diyc0 is 172.16.0.1\n\n    -m, --mem            maximum size of the memory in MB allowed for the container\n                         by default there no explicit limit defined.\n\n    -v, --verbose        more verbose output\n\n    <NAME>               name of the container, needs to be unique\n\n    <IMAGE>              image to be used for the container, must be a directory name\n                         under the images directory\n\n    <CMD>                command to be executed inside the container\n\n\n\n\n\nExample: Get a container running\n#\n\n\nThis is an example session showing how to get a container with minimal\ndebian based system up and running from zero.\n\n\n\n$ git clone git@github.com:w-vi/diyc.git\nCloning into 'diyc'...\nremote: Counting objects: 9, done.\nremote: Compressing objects: 100% (8/8), done.\nremote: Total 9 (delta 1), reused 9 (delta 1), pack-reused 0\nReceiving objects: 100% (9/9), 12.95 KiB | 0 bytes/s, done.\nResolving deltas: 100% (1/1), done.\n\n$ cd diyc\n\n$ make setup\nsudo iptables -A FORWARD -i enp5s0 -o veth -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i veth -j ACCEPT || true\nsudo iptables -t nat -A POSTROUTING -s 172.16.0.0/16 -j MASQUERADE || true\nsudo ip link add name diyc0 type bridge || true\nsudo ip addr add dev diyc0 172.16.0.1/24 || true\nsudo ip link set diyc0 up || true\nsudo iptables -A FORWARD -i enp5s0 -o diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o diyc0 -i diyc0 -j ACCEPT || true\nmkdir -p containers\nmkdir -p images\n\n$ make\ngcc -std=c99 -Wall -Werror -O2 src/diyc.c -o diyc\ngcc -std=c99 -Wall -Werror -O2 src/nsexec.c -o nsexec\n\n$ docker pull debian\nUsing default tag: latest\nlatest: Pulling from library/debian\nDigest: sha256:72f784399fd2719b4cb4e16ef8e369a39dc67f53d978cd3e2e7bf4e502c7b793\nStatus: Image is up to date for debian:latest\n\n$ docker run -ti debian /bin/bash\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n2c924241399c        debian              \"/bin/bash\"         21 seconds ago      Up 20 seconds                           epic_leavitt\n\n$ docker export 2c924241399c >! debian.tar\n\n$ mkdir images/debian\n\n$ tar -xf debian.tar -C images/debian/\n\n$ sudo ./diyc my1 debian bash\n\n  root@my1:/> exit\n  exit\n\n\n\n\n\nExample: Network between two containers\n#\n\n\nSpin up two different containers with different IPs. In this case it\nthey are based on debian so Python and curl need to be installed\nfirst.\n\n\n\n$ sudo ./diyc -i 172.16.0.30 server debian bash\nroot@server:/> apt-get update && apt-get install python\nroot@server:/> python -m SimpleHTTPServer\nServing HTTP on 0.0.0.0 port 8000 ...\n\n$ sudo ./diyc -i 172.16.0.31 client debian bash\nroot@client:/> apt-get update && apt-get install curl\nroot@client:/> curl http://172.16.0.30:8000\n\n# it is acceessible from the host too\n$ curl http://172.16.0.30:8000\n\n\n\n\n\nRemoving exited containers\n#\n\n\nBecause containers after exit leave their filesystem behind and it is\nnot destroyed you can run it again. The data are stored in the\n\ncontainers/<name>/\n directory so as long as this direcotry exists you\ncan start and stop the container. To remove it just \nsudo rm -rf\ncontainers/<name>\n.\n\n\nRemoving the diyc0 bridge and iptables rules\n#\n\n\nJust run \nmake net-clean\n.",
            "title": "Running conatiners"
        },
        {
            "location": "/diyc/usage/#usage",
            "text": "diyc [hv][-m NUMBER] [-ip IPV4 ADDRESS] <NAME> <IMAGE> <CMD>\n\n    -h, --help           print the help\n\n    -i, --ip             ip address of the container, if not set then host\n                         network is used. It must be in the 172.16.0/16 network\n                         as the bridge diyc0 is 172.16.0.1\n\n    -m, --mem            maximum size of the memory in MB allowed for the container\n                         by default there no explicit limit defined.\n\n    -v, --verbose        more verbose output\n\n    <NAME>               name of the container, needs to be unique\n\n    <IMAGE>              image to be used for the container, must be a directory name\n                         under the images directory\n\n    <CMD>                command to be executed inside the container",
            "title": "Usage"
        },
        {
            "location": "/diyc/usage/#example-get-a-container-running",
            "text": "This is an example session showing how to get a container with minimal\ndebian based system up and running from zero.  \n$ git clone git@github.com:w-vi/diyc.git\nCloning into 'diyc'...\nremote: Counting objects: 9, done.\nremote: Compressing objects: 100% (8/8), done.\nremote: Total 9 (delta 1), reused 9 (delta 1), pack-reused 0\nReceiving objects: 100% (9/9), 12.95 KiB | 0 bytes/s, done.\nResolving deltas: 100% (1/1), done.\n\n$ cd diyc\n\n$ make setup\nsudo iptables -A FORWARD -i enp5s0 -o veth -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i veth -j ACCEPT || true\nsudo iptables -t nat -A POSTROUTING -s 172.16.0.0/16 -j MASQUERADE || true\nsudo ip link add name diyc0 type bridge || true\nsudo ip addr add dev diyc0 172.16.0.1/24 || true\nsudo ip link set diyc0 up || true\nsudo iptables -A FORWARD -i enp5s0 -o diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o diyc0 -i diyc0 -j ACCEPT || true\nmkdir -p containers\nmkdir -p images\n\n$ make\ngcc -std=c99 -Wall -Werror -O2 src/diyc.c -o diyc\ngcc -std=c99 -Wall -Werror -O2 src/nsexec.c -o nsexec\n\n$ docker pull debian\nUsing default tag: latest\nlatest: Pulling from library/debian\nDigest: sha256:72f784399fd2719b4cb4e16ef8e369a39dc67f53d978cd3e2e7bf4e502c7b793\nStatus: Image is up to date for debian:latest\n\n$ docker run -ti debian /bin/bash\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n2c924241399c        debian              \"/bin/bash\"         21 seconds ago      Up 20 seconds                           epic_leavitt\n\n$ docker export 2c924241399c >! debian.tar\n\n$ mkdir images/debian\n\n$ tar -xf debian.tar -C images/debian/\n\n$ sudo ./diyc my1 debian bash\n\n  root@my1:/> exit\n  exit",
            "title": "Example: Get a container running"
        },
        {
            "location": "/diyc/usage/#example-network-between-two-containers",
            "text": "Spin up two different containers with different IPs. In this case it\nthey are based on debian so Python and curl need to be installed\nfirst.  \n$ sudo ./diyc -i 172.16.0.30 server debian bash\nroot@server:/> apt-get update && apt-get install python\nroot@server:/> python -m SimpleHTTPServer\nServing HTTP on 0.0.0.0 port 8000 ...\n\n$ sudo ./diyc -i 172.16.0.31 client debian bash\nroot@client:/> apt-get update && apt-get install curl\nroot@client:/> curl http://172.16.0.30:8000\n\n# it is acceessible from the host too\n$ curl http://172.16.0.30:8000",
            "title": "Example: Network between two containers"
        },
        {
            "location": "/diyc/usage/#removing-exited-containers",
            "text": "Because containers after exit leave their filesystem behind and it is\nnot destroyed you can run it again. The data are stored in the containers/<name>/  directory so as long as this direcotry exists you\ncan start and stop the container. To remove it just  sudo rm -rf\ncontainers/<name> .",
            "title": "Removing exited containers"
        },
        {
            "location": "/diyc/usage/#removing-the-diyc0-bridge-and-iptables-rules",
            "text": "Just run  make net-clean .",
            "title": "Removing the diyc0 bridge and iptables rules"
        },
        {
            "location": "/images-containers/",
            "text": "Images and Containers\n#\n\n\nThis section covers how the container is created from an image.\n\n\nWhat is an image?\n#\n\n\nContainer images are basically \njust tarballs\n or tarballs of\ntarballs. The tarball contains files and directories a very simple way\nhow to inspect it is to export it using docker.\n\n\n\n\n\n\nSpin the desired container up, in this case a base debian image.\n\n\n$ docker run -ti debian bash\n\n\n\n\n\n\n\nIn other terminal, find the container and export it.\n\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND\nf222a193be90        debian              \"bash\"\n\n$ docker export f222a193be90 > deian.tar\n\n\n\n\n\n\n\nStop the container\n\n\nroot@f222a193be90:/> exit\n\n\n\n\n\n\n\nUntar the image into directory.\n\n\n$ mkdir debain-image\n$ tar -xf debian.tar -C debian-image\n\n\n\n\n\n\n\nInspect what's inside. It looks like a usual GNU/Linux filesystem layout.\n\n\n$ ls -la debian-image\ntotal 92\ndrwxr-xr-x  21 wvi wvi  4096 23.04.2017 11:07 ./\ndrwxrwxrwx 113 wvi wvi 12288 23.04.2017 11:07 ../\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:29 bin/\ndrwxr-xr-x   2 wvi wvi  4096 28.12.2016 18:42 boot/\ndrwxr-xr-x   4 wvi wvi  4096 23.04.2017 11:00 dev/\ndrwxr-xr-x  41 wvi wvi  4096 23.04.2017 11:00 etc/\ndrwxr-xr-x   2 wvi wvi  4096 28.12.2016 18:42 home/\ndrwxr-xr-x   9 wvi wvi  4096 27.11.2014 20:59 lib/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:27 lib64/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:26 media/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:26 mnt/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:26 opt/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:29 proc/\ndrwx------   2 wvi wvi  4096 21.03.2017 00:26 root/\ndrwxr-xr-x   3 wvi wvi  4096 21.03.2017 00:26 run/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:29 sbin/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:26 srv/\ndrwxr-xr-x   2 wvi wvi  4096 06.04.2015 20:44 sys/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:29 tmp/\ndrwxr-xr-x  10 wvi wvi  4096 21.03.2017 00:26 usr/\ndrwxr-xr-x  11 wvi wvi  4096 21.03.2017 00:26 var/\n-rwxr-xr-x   1 wvi wvi     0 23.04.2017 11:00 .dockerenv*\n\n\n\n\n\n\n\nCreating the image\n#\n\n\nTo create an image for the diyC the easiest is to \nexport the docker\nimage\n.\n\n\nGenerally for containers there are many other ways how to create an\nimage but it is out of scope of this project so here is just a few\npointers.\n\n\n\n\n\n\nStatically linked programs where you need just that one binary\n  nothing else so something along those lines should suffice. That's\n  for example what you can do with \nGo programs\n.\n\n\n$ mkdir image\n$ cp <my-statically-linked-binary> image\n$ tar -cf image.tar image\n\n\n\n\n\n\n\nhttps://buildroot.org/\n is a toolbox for\n  creating embedded linux systems but you can very easily create a\n  custom installation which will be very small. See a\n  \ngreat talk on this topic from Brian \"Redbeard\" Harrington\n from\n  \ncoreOS\n.\n\n\n\n\n\n\nGet your filesystem layout and copy files needed. you can use\n  package managers like \ndnf\n, \nyum\n, \ndebootsrap\n etc. and tar the\n  structure up.\n\n\n\n\n\n\nEasy way to verify that the tarball makes sense is to import it to docker\nusing \ndocker import tarball.tar\n.\n\n\nHow a container is created from an image?\n#\n\n\nThe main magic is layers becaue containers are\nlike \nOgres\n. The\ncontainer's filesystem is usually made of at least two layers many\ntimes there are more layers involved but that doesn't change the core\nconcept where one layer is the image and the other is a writeable\ntemporary directory for the container to write files so that the image\nremains immutable. To achieve such behaviour you need a so\ncalled \nunion mount\n which\nbasically mounts a new filesystem combining two or more\ndirectories/filesystems together into one.\n\n\n\n\nAbove: Simplified unioning filesystem scheme\n\n\nSuch a unified filesystem is then mounted under some temp working directory\nand in the container it is changed to be the root\nfilesystem using the\n\npivot_root syscall\n.\n\npivot_root\n\nis almost like\na \nchroot\n but you\nget to keep access to the original old root so you can for example\ncopy some configuration files to the new root.\n\n\n\n\nCode\n\n\nSee the implementation in \ndiy.c:304-330\n\n\n\n\nVery similar behaviour is also possible using completely different\napproaches, i.e utilizing subvolumes and snapshots\nof \nbtrfs\n or\nusing \ndevicemapper\n. Docker\nuses devicemapper approach on many systems by default and has a very\ngood description of the \n\ndevicemapper approach\n.\n\n\nUnioning filesystems in Linux\n#\n\n\nHistorically there were couple of options on Linux but only one of\nthem ended up in the mainline kernel. Describing the history and\ndetails is out of the scope but the main ones are :\n\n\n\n\nUnionFS\n\n\naufs\n\n\noverlayFS\n\n\n\n\nToday the easisest option is to use overlayfs filesystem because it\nwas merged to mainline kernel in version 3.18. It is actually called\noverlay since the merge. To check if you are able to use it see\n\n/proc/filesystems\n file (\nman 5 filesystems\n).\n\n\n\n\noverlay kernel module\n\n\nVery often it does not show up in the \n/proc/filesystems\n because\nit is loaded only if it is used so try \nmodprobe overlay\n to load the kernel module.\n\n\n\n\nUsing overlay filesystem\n#\n\n\nIn the overlayfs there are two layers, \nlowerdir\n which is\nalways read only and \nupperdir\n which is writeable. You can actually have\nmore \nlowerdir\n directories which are all read only as any changes are\nalways stored in the \nupperdir\n. It can be used in many ways\n(i.e. Live CDs) and is not specific to containers.\n\n\nYou can give it a try yourself easily from a command line.\n\n\nOverlay \nmount(8)\n options.\n\n\n# mount -t overlay overlay -o lowerdir=/lower1:/lower2,upperdir=/upper,workdir=/work /merged\n\n\n\n\n\n\nworkdir\n\n\nThe \nworkdir\n parameter must be on the same filesystem as the\n\nuppperdir\n directory and it is used for certain atomic\noperations. \nlowerdir\n can be on a different filesystem though.\n\n\n\n\n# In tmp create the needed directory structure\n$ mkdir /tmp/lower /tmp/upper /tmp/workdir /tmp/merged\n# and mount an overlay fs\n$ sudo mount -t overlay -o \\\n  lowerdir=/tmp/lower,\\\n  upperdir=/tmp/upper,\\\n  workdir=/tmp/workdir \\\n  none /tmp/merged\n\n\n\n\nIf you play around creating/writing/deleting files and directories in\nthe \nlower\n, \nupper\n and  \nmerged\n you can observe the following.\n\n\nObservations\n#\n\n\n\n\n\n\nIf there are directories in both \nlower\n and \nupper\n their content\n  is merged.\n\n\n\n\n\n\nFiles created in the \nlower\n or \nupper\n directory are visible in the\n  \nmerged\n.\n\n\n\n\n\n\nAny files created in the merged are actually created in the \nupper\n.\n\n\n\n\n\n\nWriting to existing files appears again only in \nupper\n even if the\n  file was originally in \nlower\n, the file is \ncopied up\n.\n\n\n\n\n\n\nDeleteing a file or directory in \nmerged\n that was in the \nlower\n,\n  removes it from merged but not \nlower\n. It creates a so called\n  \"whiteout\" file/directory in the \nupper\n.\n\n\n\n\n\n\nConatiner filesystem is created in the same fashion, image is the\n\nlowerdir\n and container specific files are in the \nupperdir\n. Inside the\ncontainer you see the \nmerged\n.\n\n\nMore to read\n#\n\n\n\n\nOverlay documentation in kernel\n\n\nDocker and OverlayFS in practice\n\n\nDocker and the Device Mapper storage driver\n\n\nUnioning file systems: Architecture, features, and design choices\n\n\nUnion file systems: Implementations, part I\n\n\nUnioning file systems: Implementations, part 2\n\n\nAnother union filesystem approach",
            "title": "Images and containers"
        },
        {
            "location": "/images-containers/#images-and-containers",
            "text": "This section covers how the container is created from an image.",
            "title": "Images and Containers"
        },
        {
            "location": "/images-containers/#what-is-an-image",
            "text": "Container images are basically  just tarballs  or tarballs of\ntarballs. The tarball contains files and directories a very simple way\nhow to inspect it is to export it using docker.    Spin the desired container up, in this case a base debian image.  $ docker run -ti debian bash    In other terminal, find the container and export it.  $ docker ps\nCONTAINER ID        IMAGE               COMMAND\nf222a193be90        debian              \"bash\"\n\n$ docker export f222a193be90 > deian.tar    Stop the container  root@f222a193be90:/> exit    Untar the image into directory.  $ mkdir debain-image\n$ tar -xf debian.tar -C debian-image    Inspect what's inside. It looks like a usual GNU/Linux filesystem layout.  $ ls -la debian-image\ntotal 92\ndrwxr-xr-x  21 wvi wvi  4096 23.04.2017 11:07 ./\ndrwxrwxrwx 113 wvi wvi 12288 23.04.2017 11:07 ../\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:29 bin/\ndrwxr-xr-x   2 wvi wvi  4096 28.12.2016 18:42 boot/\ndrwxr-xr-x   4 wvi wvi  4096 23.04.2017 11:00 dev/\ndrwxr-xr-x  41 wvi wvi  4096 23.04.2017 11:00 etc/\ndrwxr-xr-x   2 wvi wvi  4096 28.12.2016 18:42 home/\ndrwxr-xr-x   9 wvi wvi  4096 27.11.2014 20:59 lib/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:27 lib64/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:26 media/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:26 mnt/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:26 opt/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:29 proc/\ndrwx------   2 wvi wvi  4096 21.03.2017 00:26 root/\ndrwxr-xr-x   3 wvi wvi  4096 21.03.2017 00:26 run/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:29 sbin/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:26 srv/\ndrwxr-xr-x   2 wvi wvi  4096 06.04.2015 20:44 sys/\ndrwxr-xr-x   2 wvi wvi  4096 21.03.2017 00:29 tmp/\ndrwxr-xr-x  10 wvi wvi  4096 21.03.2017 00:26 usr/\ndrwxr-xr-x  11 wvi wvi  4096 21.03.2017 00:26 var/\n-rwxr-xr-x   1 wvi wvi     0 23.04.2017 11:00 .dockerenv*",
            "title": "What is an image?"
        },
        {
            "location": "/images-containers/#creating-the-image",
            "text": "To create an image for the diyC the easiest is to  export the docker\nimage .  Generally for containers there are many other ways how to create an\nimage but it is out of scope of this project so here is just a few\npointers.    Statically linked programs where you need just that one binary\n  nothing else so something along those lines should suffice. That's\n  for example what you can do with  Go programs .  $ mkdir image\n$ cp <my-statically-linked-binary> image\n$ tar -cf image.tar image    https://buildroot.org/  is a toolbox for\n  creating embedded linux systems but you can very easily create a\n  custom installation which will be very small. See a\n   great talk on this topic from Brian \"Redbeard\" Harrington  from\n   coreOS .    Get your filesystem layout and copy files needed. you can use\n  package managers like  dnf ,  yum ,  debootsrap  etc. and tar the\n  structure up.    Easy way to verify that the tarball makes sense is to import it to docker\nusing  docker import tarball.tar .",
            "title": "Creating the image"
        },
        {
            "location": "/images-containers/#how-a-container-is-created-from-an-image",
            "text": "The main magic is layers becaue containers are\nlike  Ogres . The\ncontainer's filesystem is usually made of at least two layers many\ntimes there are more layers involved but that doesn't change the core\nconcept where one layer is the image and the other is a writeable\ntemporary directory for the container to write files so that the image\nremains immutable. To achieve such behaviour you need a so\ncalled  union mount  which\nbasically mounts a new filesystem combining two or more\ndirectories/filesystems together into one.   Above: Simplified unioning filesystem scheme  Such a unified filesystem is then mounted under some temp working directory\nand in the container it is changed to be the root\nfilesystem using the pivot_root syscall . pivot_root \nis almost like\na  chroot  but you\nget to keep access to the original old root so you can for example\ncopy some configuration files to the new root.   Code  See the implementation in  diy.c:304-330   Very similar behaviour is also possible using completely different\napproaches, i.e utilizing subvolumes and snapshots\nof  btrfs  or\nusing  devicemapper . Docker\nuses devicemapper approach on many systems by default and has a very\ngood description of the  devicemapper approach .",
            "title": "How a container is created from an image?"
        },
        {
            "location": "/images-containers/#unioning-filesystems-in-linux",
            "text": "Historically there were couple of options on Linux but only one of\nthem ended up in the mainline kernel. Describing the history and\ndetails is out of the scope but the main ones are :   UnionFS  aufs  overlayFS   Today the easisest option is to use overlayfs filesystem because it\nwas merged to mainline kernel in version 3.18. It is actually called\noverlay since the merge. To check if you are able to use it see /proc/filesystems  file ( man 5 filesystems ).   overlay kernel module  Very often it does not show up in the  /proc/filesystems  because\nit is loaded only if it is used so try  modprobe overlay  to load the kernel module.",
            "title": "Unioning filesystems in Linux"
        },
        {
            "location": "/images-containers/#using-overlay-filesystem",
            "text": "In the overlayfs there are two layers,  lowerdir  which is\nalways read only and  upperdir  which is writeable. You can actually have\nmore  lowerdir  directories which are all read only as any changes are\nalways stored in the  upperdir . It can be used in many ways\n(i.e. Live CDs) and is not specific to containers.  You can give it a try yourself easily from a command line.  Overlay  mount(8)  options.  # mount -t overlay overlay -o lowerdir=/lower1:/lower2,upperdir=/upper,workdir=/work /merged   workdir  The  workdir  parameter must be on the same filesystem as the uppperdir  directory and it is used for certain atomic\noperations.  lowerdir  can be on a different filesystem though.   # In tmp create the needed directory structure\n$ mkdir /tmp/lower /tmp/upper /tmp/workdir /tmp/merged\n# and mount an overlay fs\n$ sudo mount -t overlay -o \\\n  lowerdir=/tmp/lower,\\\n  upperdir=/tmp/upper,\\\n  workdir=/tmp/workdir \\\n  none /tmp/merged  If you play around creating/writing/deleting files and directories in\nthe  lower ,  upper  and   merged  you can observe the following.",
            "title": "Using overlay filesystem"
        },
        {
            "location": "/images-containers/#observations",
            "text": "If there are directories in both  lower  and  upper  their content\n  is merged.    Files created in the  lower  or  upper  directory are visible in the\n   merged .    Any files created in the merged are actually created in the  upper .    Writing to existing files appears again only in  upper  even if the\n  file was originally in  lower , the file is  copied up .    Deleteing a file or directory in  merged  that was in the  lower ,\n  removes it from merged but not  lower . It creates a so called\n  \"whiteout\" file/directory in the  upper .    Conatiner filesystem is created in the same fashion, image is the lowerdir  and container specific files are in the  upperdir . Inside the\ncontainer you see the  merged .",
            "title": "Observations"
        },
        {
            "location": "/images-containers/#more-to-read",
            "text": "Overlay documentation in kernel  Docker and OverlayFS in practice  Docker and the Device Mapper storage driver  Unioning file systems: Architecture, features, and design choices  Union file systems: Implementations, part I  Unioning file systems: Implementations, part 2  Another union filesystem approach",
            "title": "More to read"
        }
    ]
}