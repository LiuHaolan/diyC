{
    "docs": [
        {
            "location": "/",
            "text": "Linux containers from scratch - diyC\n#\n\n\nLinux containers exist for a while and are now a mainstream\ntopic. This is an introduction on how their are created and what they\nactually are made of. If you want to see the code then head directly\nto \nthe github repo\n otherwise read on\nthe topic you are interested in.\n\n\nNote\n: Any suggestions or comments are welcome please don't hesitate\nand \nfile an issue on github\n.\n\n\nWhat is diyC\n#\n\n\nIt is a simple educational Linux container runtime. It is\nintentionally simple and leaves a lot of stuff out. It is a single C\nfile of roughly 500 lines including comments showing the core features\nof the Linux used to build containers. It includes also the creation\nof a container from an image to clarify how images and containers are\nrelated.\n\n\nImportant note\n#\n\n\nIt plays with iptables to get the routing and isolation running so if\nyou have your own iptables rules make sure to save them before doing\nanything else \nsudo iptables-save\n and \nsudo iptables-restore\n to\nrecover them in case something goes awry.\n\n\nPrerequisites\n#\n\n\nThis is a educational piece of software and has not been tested on\nmany systems yet, to give it a go make sure you have the following:\n\n\n\n\nrecent Linux kernel supporting needed namespaces and cgroups\n\n\noverlayfs \n\n\nip tool (iproute2 package)\n\n\niptables\n\n\ngcc\n\n\nmake\n\n\nbash\n\n\n\n\nApart from overlayfs most of the distros are prepared and ready, if\nnot please consult your distro package manager. Overlayfs is in the\nmainline kernel so it should be straightforward. It was merged in\nversion 3.18 but has been improved a lot so you should aim for kernel\n4.x.\n\n\nNote\n: Kernel needs to be configured to support following namespaces\nPID, mount, network and UTS, cgroups are needed as well. Most of the\nGNU/Linux distros have this support enabled by default.\n\n\nInstallation\n#\n\n\n\n\nmake setup\n\n\n\n\nIt creates the necessary directory structure as well as prepares the\nnetworking part like iptables rules, bridge (diyc0) and so on. To\nremove the networking bits like bridge and iptables rules run \nmake\nnet-clean\n which removes them all.\n\n\n\n\nmake\n\n\n\n\nBuilds the runtime.\n\n\n\n\nDone\n\n\n\n\nnsexec\n#\n\n\nThe above steps also build a \nnsexec\n binary which is is a very\nsimple program that executes a local (host) command in namespaces. See\n\nnsexec --help\n to see what namespaces are available. Usage is very\nsimple \nsudo ./nsexec -pnu myhost bash\n will start a new bash in new\npid, network and UTS namespace.\n\n\nPreparing images\n#\n\n\nThe image import and creation is not present but because images are\njust \nTARBALLS\n there is no need for anything fancy.\n\n\nCreating the tarball using docker\n#\n\n\nUsing docker is the most straightforward. \ndocker pull\n the image you\nwant, spin it up by \ndocker run -ti <image> <command>\n and in\ndifferent terminal do \ndocker export <container> > myimage.tar\n. You\nhave the tarball ready.\n\n\nInstalling image\n#\n\n\nmake setup\n creates an \nimages\n subdirectory so \nmkdir\nimages/myimage\n followed by \ntar -xf myimage.tar -C images/myimage/\n\nshould do the trick.\n\n\nSee \nhow to run a container\n.",
            "title": "Home"
        },
        {
            "location": "/#linux-containers-from-scratch-diyc",
            "text": "Linux containers exist for a while and are now a mainstream\ntopic. This is an introduction on how their are created and what they\nactually are made of. If you want to see the code then head directly\nto  the github repo  otherwise read on\nthe topic you are interested in.  Note : Any suggestions or comments are welcome please don't hesitate\nand  file an issue on github .",
            "title": "Linux containers from scratch - diyC"
        },
        {
            "location": "/#what-is-diyc",
            "text": "It is a simple educational Linux container runtime. It is\nintentionally simple and leaves a lot of stuff out. It is a single C\nfile of roughly 500 lines including comments showing the core features\nof the Linux used to build containers. It includes also the creation\nof a container from an image to clarify how images and containers are\nrelated.",
            "title": "What is diyC"
        },
        {
            "location": "/#important-note",
            "text": "It plays with iptables to get the routing and isolation running so if\nyou have your own iptables rules make sure to save them before doing\nanything else  sudo iptables-save  and  sudo iptables-restore  to\nrecover them in case something goes awry.",
            "title": "Important note"
        },
        {
            "location": "/#prerequisites",
            "text": "This is a educational piece of software and has not been tested on\nmany systems yet, to give it a go make sure you have the following:   recent Linux kernel supporting needed namespaces and cgroups  overlayfs   ip tool (iproute2 package)  iptables  gcc  make  bash   Apart from overlayfs most of the distros are prepared and ready, if\nnot please consult your distro package manager. Overlayfs is in the\nmainline kernel so it should be straightforward. It was merged in\nversion 3.18 but has been improved a lot so you should aim for kernel\n4.x.  Note : Kernel needs to be configured to support following namespaces\nPID, mount, network and UTS, cgroups are needed as well. Most of the\nGNU/Linux distros have this support enabled by default.",
            "title": "Prerequisites"
        },
        {
            "location": "/#installation",
            "text": "make setup   It creates the necessary directory structure as well as prepares the\nnetworking part like iptables rules, bridge (diyc0) and so on. To\nremove the networking bits like bridge and iptables rules run  make\nnet-clean  which removes them all.   make   Builds the runtime.   Done",
            "title": "Installation"
        },
        {
            "location": "/#nsexec",
            "text": "The above steps also build a  nsexec  binary which is is a very\nsimple program that executes a local (host) command in namespaces. See nsexec --help  to see what namespaces are available. Usage is very\nsimple  sudo ./nsexec -pnu myhost bash  will start a new bash in new\npid, network and UTS namespace.",
            "title": "nsexec"
        },
        {
            "location": "/#preparing-images",
            "text": "The image import and creation is not present but because images are\njust  TARBALLS  there is no need for anything fancy.",
            "title": "Preparing images"
        },
        {
            "location": "/#creating-the-tarball-using-docker",
            "text": "Using docker is the most straightforward.  docker pull  the image you\nwant, spin it up by  docker run -ti <image> <command>  and in\ndifferent terminal do  docker export <container> > myimage.tar . You\nhave the tarball ready.",
            "title": "Creating the tarball using docker"
        },
        {
            "location": "/#installing-image",
            "text": "make setup  creates an  images  subdirectory so  mkdir\nimages/myimage  followed by  tar -xf myimage.tar -C images/myimage/ \nshould do the trick.  See  how to run a container .",
            "title": "Installing image"
        },
        {
            "location": "/usage/",
            "text": "Usage\n#\n\n\n    diyc [hv][-m NUMBER] [-ip IPV4 ADDRESS] <NAME> <IMAGE> <CMD>\n\n    -h, --help           print the help\n\n    -i, --ip             ip address of the container, if not set then host\n                         network is used. It must be in the 172.16.0/16 network\n                         as the bridge diyc0 is 172.16.0.1\n\n    -m, --mem            maximum size of the memory in MB allowed for the container\n                         by default there no explicit limit defined.\n\n    -v, --verbose        more verbose output\n\n    <NAME>               name of the container, needs to be unique\n\n    <IMAGE>              image to be used for the container, must be a directory name\n                         under the images directory\n\n    <CMD>                command to be executed inside the container\n\n\n\n\n\nExample: Get a container running\n#\n\n\nThis is an example session showing how to get a container with minimal\ndebian based system up and running from zero.\n\n\n\n$ git clone git@github.com:w-vi/diyc.git\nCloning into 'diyc'...\nremote: Counting objects: 9, done.\nremote: Compressing objects: 100% (8/8), done.\nremote: Total 9 (delta 1), reused 9 (delta 1), pack-reused 0\nReceiving objects: 100% (9/9), 12.95 KiB | 0 bytes/s, done.\nResolving deltas: 100% (1/1), done.\n\n$ cd diyc\n\n$ make setup\nsudo iptables -A FORWARD -i enp5s0 -o veth -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i veth -j ACCEPT || true\nsudo iptables -t nat -A POSTROUTING -s 172.16.0.0/16 -j MASQUERADE || true\nsudo ip link add name diyc0 type bridge || true\nsudo ip addr add dev diyc0 172.16.0.1/24 || true\nsudo ip link set diyc0 up || true\nsudo iptables -A FORWARD -i enp5s0 -o diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o diyc0 -i diyc0 -j ACCEPT || true\nmkdir -p containers\nmkdir -p images\n\n$ make\ngcc -std=c99 -Wall -Werror -O2 src/diyc.c -o diyc\ngcc -std=c99 -Wall -Werror -O2 src/nsexec.c -o nsexec\n\n$ docker pull debian\nUsing default tag: latest\nlatest: Pulling from library/debian\nDigest: sha256:72f784399fd2719b4cb4e16ef8e369a39dc67f53d978cd3e2e7bf4e502c7b793\nStatus: Image is up to date for debian:latest\n\n$ docker run -ti debian /bin/bash\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n2c924241399c        debian              \"/bin/bash\"         21 seconds ago      Up 20 seconds                           epic_leavitt\n\n$ docker export 2c924241399c >! debian.tar\n\n$ mkdir images/debian\n\n$ tar -xf debian.tar -C images/debian/\n\n$ sudo ./diyc my1 debian bash\n\n  root@my1:/> exit\n  exit\n\n\n\n\n\nExample: Network between two containers\n#\n\n\nSpin up two different containers with different IPs. In this case it\nthey are based on debian so Python and curl need to be installed\nfirst.\n\n\n\n$ sudo ./diyc -i 172.16.0.30 server debian bash\nroot@server:/> apt-get update && apt-get install python\nroot@server:/> python -m SimpleHTTPServer\nServing HTTP on 0.0.0.0 port 8000 ...\n\n$ sudo ./diyc -i 172.16.0.31 client debian bash\nroot@client:/> apt-get update && apt-get install curl\nroot@client:/> curl http://172.16.0.30:8000\n\n# it is acceessible from the host too\n$ curl http://172.16.0.30:8000\n\n\n\n\n\nRemoving exited containers\n#\n\n\nBecause containers after exit leave their filesystem behind and it is\nnot destroyed you can run it again. The data are stored in the\n\ncontainers/<name>/\n directory so as long as this direcotry exists you\ncan start and stop the container. To remove it just \nsudo rm -rf\ncontainers/<name>\n it.",
            "title": "Usage"
        },
        {
            "location": "/usage/#usage",
            "text": "diyc [hv][-m NUMBER] [-ip IPV4 ADDRESS] <NAME> <IMAGE> <CMD>\n\n    -h, --help           print the help\n\n    -i, --ip             ip address of the container, if not set then host\n                         network is used. It must be in the 172.16.0/16 network\n                         as the bridge diyc0 is 172.16.0.1\n\n    -m, --mem            maximum size of the memory in MB allowed for the container\n                         by default there no explicit limit defined.\n\n    -v, --verbose        more verbose output\n\n    <NAME>               name of the container, needs to be unique\n\n    <IMAGE>              image to be used for the container, must be a directory name\n                         under the images directory\n\n    <CMD>                command to be executed inside the container",
            "title": "Usage"
        },
        {
            "location": "/usage/#example-get-a-container-running",
            "text": "This is an example session showing how to get a container with minimal\ndebian based system up and running from zero.  \n$ git clone git@github.com:w-vi/diyc.git\nCloning into 'diyc'...\nremote: Counting objects: 9, done.\nremote: Compressing objects: 100% (8/8), done.\nremote: Total 9 (delta 1), reused 9 (delta 1), pack-reused 0\nReceiving objects: 100% (9/9), 12.95 KiB | 0 bytes/s, done.\nResolving deltas: 100% (1/1), done.\n\n$ cd diyc\n\n$ make setup\nsudo iptables -A FORWARD -i enp5s0 -o veth -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i veth -j ACCEPT || true\nsudo iptables -t nat -A POSTROUTING -s 172.16.0.0/16 -j MASQUERADE || true\nsudo ip link add name diyc0 type bridge || true\nsudo ip addr add dev diyc0 172.16.0.1/24 || true\nsudo ip link set diyc0 up || true\nsudo iptables -A FORWARD -i enp5s0 -o diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o diyc0 -i diyc0 -j ACCEPT || true\nmkdir -p containers\nmkdir -p images\n\n$ make\ngcc -std=c99 -Wall -Werror -O2 src/diyc.c -o diyc\ngcc -std=c99 -Wall -Werror -O2 src/nsexec.c -o nsexec\n\n$ docker pull debian\nUsing default tag: latest\nlatest: Pulling from library/debian\nDigest: sha256:72f784399fd2719b4cb4e16ef8e369a39dc67f53d978cd3e2e7bf4e502c7b793\nStatus: Image is up to date for debian:latest\n\n$ docker run -ti debian /bin/bash\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n2c924241399c        debian              \"/bin/bash\"         21 seconds ago      Up 20 seconds                           epic_leavitt\n\n$ docker export 2c924241399c >! debian.tar\n\n$ mkdir images/debian\n\n$ tar -xf debian.tar -C images/debian/\n\n$ sudo ./diyc my1 debian bash\n\n  root@my1:/> exit\n  exit",
            "title": "Example: Get a container running"
        },
        {
            "location": "/usage/#example-network-between-two-containers",
            "text": "Spin up two different containers with different IPs. In this case it\nthey are based on debian so Python and curl need to be installed\nfirst.  \n$ sudo ./diyc -i 172.16.0.30 server debian bash\nroot@server:/> apt-get update && apt-get install python\nroot@server:/> python -m SimpleHTTPServer\nServing HTTP on 0.0.0.0 port 8000 ...\n\n$ sudo ./diyc -i 172.16.0.31 client debian bash\nroot@client:/> apt-get update && apt-get install curl\nroot@client:/> curl http://172.16.0.30:8000\n\n# it is acceessible from the host too\n$ curl http://172.16.0.30:8000",
            "title": "Example: Network between two containers"
        },
        {
            "location": "/usage/#removing-exited-containers",
            "text": "Because containers after exit leave their filesystem behind and it is\nnot destroyed you can run it again. The data are stored in the containers/<name>/  directory so as long as this direcotry exists you\ncan start and stop the container. To remove it just  sudo rm -rf\ncontainers/<name>  it.",
            "title": "Removing exited containers"
        }
    ]
}