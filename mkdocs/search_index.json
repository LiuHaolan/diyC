{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to diyC\n\n\nA simple educational Linux container runtime. It is intentionally\nsimple and leaves a lot of stuff out. It is a single C file of roughly\n400 lines showing the core features of the Linux used to build\ncontainers. It includes also the creation of a container from an image\nto clarify how these work together.\n\n\nImportant note\n\n\nIt plays with iptables to get the routing and isolation running so if\nyou have your own iptables rules make sure to save them before doing\nanything else \nsudo iptables-save\n and \nsudo iptables-restore\n to\nrecover them in case something goes awry.\n\n\nPrerequisites\n\n\nThis is a educational piece of software and is not very portable, here\nare the prerequisites:\n\n\n\n\nrecent Linux kernel supporting needed namespaces and cgroups\n\n\noverlayfs installed\n\n\nip tool (iproute2 package)\n\n\niptables\n\n\ngcc\n\n\nmake\n\n\nbash\n\n\n\n\nApart from overlayfs most of the distros are prepared and ready, if\nnot please consult your distro package manager. Overlayfs is in the\nmainline kernel so it should be straightforward. It was merged in\nversion 3.18 but has been improved a lot so you should aim for kernel\n4.x.\n\n\nNote\n: Kernel needs to be configured to support following namespaces\nPID, mount, network and UTS, cgroups are needed as well. Most of the GNU/Linux distros have\nthis support enabled by default.\n\n\nInstallation\n\n\n\n\nmake setup\n\n\n\n\nIt creates the necessary directory structure as well as prepares the\nnetworking part like iptables rules, bridge (diyc0) and so on. To\nremove the networking bits like bridge and iptables rules run \nmake\nnet-clean\n which removes them all.\n\n\n\n\nmake\n\n\n\n\nBuilds the runtime.\n\n\n\n\nDone\n\n\n\n\nIt also builds a \nnsexec\n which executes a local command in namespaces. See \nnsexec --help\n to see what namespaces are available. Usage is very simple \nsudo ./nsexec -pnu myhost bash\n will start a new bash in new pid, network and UTS namespace.\n\n\nPreparing images\n\n\nThe image import and creation is not present but because images are\njust \nTARBALLS\n there is no need for anything fancy.\n\n\nCreating the tarball using docker\n\n\nUsing docker is the most straightforward. \ndocker pull\n the image you\nwant, spin it up by \ndocker run -ti <image> <command>\n and in\ndifferent terminal do \ndocker export <container> > myimage.tar\n. You\nhave the tarball ready.\n\n\nInstalling image\n\n\nmake setup\n creates an \nimages\n subdirectory so \nmkdir\nimages/myimage\n followed by \ntar -xf myimage.tar -C images/myimage/\n\nshould do the trick.\n\n\nSee \nUsage to run a container",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-diyc",
            "text": "A simple educational Linux container runtime. It is intentionally\nsimple and leaves a lot of stuff out. It is a single C file of roughly\n400 lines showing the core features of the Linux used to build\ncontainers. It includes also the creation of a container from an image\nto clarify how these work together.",
            "title": "Welcome to diyC"
        },
        {
            "location": "/#important-note",
            "text": "It plays with iptables to get the routing and isolation running so if\nyou have your own iptables rules make sure to save them before doing\nanything else  sudo iptables-save  and  sudo iptables-restore  to\nrecover them in case something goes awry.",
            "title": "Important note"
        },
        {
            "location": "/#prerequisites",
            "text": "This is a educational piece of software and is not very portable, here\nare the prerequisites:   recent Linux kernel supporting needed namespaces and cgroups  overlayfs installed  ip tool (iproute2 package)  iptables  gcc  make  bash   Apart from overlayfs most of the distros are prepared and ready, if\nnot please consult your distro package manager. Overlayfs is in the\nmainline kernel so it should be straightforward. It was merged in\nversion 3.18 but has been improved a lot so you should aim for kernel\n4.x.  Note : Kernel needs to be configured to support following namespaces\nPID, mount, network and UTS, cgroups are needed as well. Most of the GNU/Linux distros have\nthis support enabled by default.",
            "title": "Prerequisites"
        },
        {
            "location": "/#installation",
            "text": "make setup   It creates the necessary directory structure as well as prepares the\nnetworking part like iptables rules, bridge (diyc0) and so on. To\nremove the networking bits like bridge and iptables rules run  make\nnet-clean  which removes them all.   make   Builds the runtime.   Done   It also builds a  nsexec  which executes a local command in namespaces. See  nsexec --help  to see what namespaces are available. Usage is very simple  sudo ./nsexec -pnu myhost bash  will start a new bash in new pid, network and UTS namespace.",
            "title": "Installation"
        },
        {
            "location": "/#preparing-images",
            "text": "The image import and creation is not present but because images are\njust  TARBALLS  there is no need for anything fancy.",
            "title": "Preparing images"
        },
        {
            "location": "/#creating-the-tarball-using-docker",
            "text": "Using docker is the most straightforward.  docker pull  the image you\nwant, spin it up by  docker run -ti <image> <command>  and in\ndifferent terminal do  docker export <container> > myimage.tar . You\nhave the tarball ready.",
            "title": "Creating the tarball using docker"
        },
        {
            "location": "/#installing-image",
            "text": "make setup  creates an  images  subdirectory so  mkdir\nimages/myimage  followed by  tar -xf myimage.tar -C images/myimage/ \nshould do the trick.  See  Usage to run a container",
            "title": "Installing image"
        },
        {
            "location": "/usage/",
            "text": "Usage\n\n\ndiyc [hv][-m NUMBER] [-ip IPV4 ADDRESS] <NAME> <IMAGE> <CMD>\n\n    -h, --help           print the help\n\n    -i, --ip             ip address of the container, if not set then host\n                         network is used. It must be in the 172.16.0/16 network\n                         as the bridge diyc0 is 172.16.0.1\n\n    -m, --mem            maximum size of the memory in MB allowed for the container\n                         by default there no explicit limit defined.\n\n    -v, --verbose        more verbose output\n\n    <NAME>               name of the container, needs to be unique\n\n    <IMAGE>              image to be used for the container, must be a directory name\n                         under the images directory\n\n    <CMD>                command to be executed inside the container\n\n\n\n\n\nExample to get a container running\n\n\n\n$ git clone git@github.com:w-vi/diyc.git\nCloning into 'diyc'...\nremote: Counting objects: 9, done.\nremote: Compressing objects: 100% (8/8), done.\nremote: Total 9 (delta 1), reused 9 (delta 1), pack-reused 0\nReceiving objects: 100% (9/9), 12.95 KiB | 0 bytes/s, done.\nResolving deltas: 100% (1/1), done.\n\n$ cd diyc\n\n$ make setup\nsudo iptables -A FORWARD -i enp5s0 -o veth -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i veth -j ACCEPT || true\nsudo iptables -t nat -A POSTROUTING -s 172.16.0.0/16 -j MASQUERADE || true\nsudo ip link add name diyc0 type bridge || true\nsudo ip addr add dev diyc0 172.16.0.1/24 || true\nsudo ip link set diyc0 up || true\nsudo iptables -A FORWARD -i enp5s0 -o diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o diyc0 -i diyc0 -j ACCEPT || true\nmkdir -p containers\nmkdir -p images\n\n$ make\ngcc -std=c99 -Wall -Werror -O2 src/diyc.c -o diyc\ngcc -std=c99 -Wall -Werror -O2 src/nsexec.c -o nsexec\n\n$ docker pull debian\nUsing default tag: latest\nlatest: Pulling from library/debian\nDigest: sha256:72f784399fd2719b4cb4e16ef8e369a39dc67f53d978cd3e2e7bf4e502c7b793\nStatus: Image is up to date for debian:latest\n\n$ docker run -ti debian /bin/bash\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n2c924241399c        debian              \"/bin/bash\"         21 seconds ago      Up 20 seconds                           epic_leavitt\n\n$ docker export 2c924241399c >! debian.tar\n\n$ mkdir images/debian\n\n$ tar -xf debian.tar -C images/debian/\n\n$ sudo ./diyc my1 debian bash\n\n> root@my1:/# exit\n  exit",
            "title": "Usage"
        },
        {
            "location": "/usage/#usage",
            "text": "diyc [hv][-m NUMBER] [-ip IPV4 ADDRESS] <NAME> <IMAGE> <CMD>\n\n    -h, --help           print the help\n\n    -i, --ip             ip address of the container, if not set then host\n                         network is used. It must be in the 172.16.0/16 network\n                         as the bridge diyc0 is 172.16.0.1\n\n    -m, --mem            maximum size of the memory in MB allowed for the container\n                         by default there no explicit limit defined.\n\n    -v, --verbose        more verbose output\n\n    <NAME>               name of the container, needs to be unique\n\n    <IMAGE>              image to be used for the container, must be a directory name\n                         under the images directory\n\n    <CMD>                command to be executed inside the container",
            "title": "Usage"
        },
        {
            "location": "/usage/#example-to-get-a-container-running",
            "text": "$ git clone git@github.com:w-vi/diyc.git\nCloning into 'diyc'...\nremote: Counting objects: 9, done.\nremote: Compressing objects: 100% (8/8), done.\nremote: Total 9 (delta 1), reused 9 (delta 1), pack-reused 0\nReceiving objects: 100% (9/9), 12.95 KiB | 0 bytes/s, done.\nResolving deltas: 100% (1/1), done.\n\n$ cd diyc\n\n$ make setup\nsudo iptables -A FORWARD -i enp5s0 -o veth -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i veth -j ACCEPT || true\nsudo iptables -t nat -A POSTROUTING -s 172.16.0.0/16 -j MASQUERADE || true\nsudo ip link add name diyc0 type bridge || true\nsudo ip addr add dev diyc0 172.16.0.1/24 || true\nsudo ip link set diyc0 up || true\nsudo iptables -A FORWARD -i enp5s0 -o diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o enp5s0 -i diyc0 -j ACCEPT || true\nsudo iptables -A FORWARD -o diyc0 -i diyc0 -j ACCEPT || true\nmkdir -p containers\nmkdir -p images\n\n$ make\ngcc -std=c99 -Wall -Werror -O2 src/diyc.c -o diyc\ngcc -std=c99 -Wall -Werror -O2 src/nsexec.c -o nsexec\n\n$ docker pull debian\nUsing default tag: latest\nlatest: Pulling from library/debian\nDigest: sha256:72f784399fd2719b4cb4e16ef8e369a39dc67f53d978cd3e2e7bf4e502c7b793\nStatus: Image is up to date for debian:latest\n\n$ docker run -ti debian /bin/bash\n\n$ docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n2c924241399c        debian              \"/bin/bash\"         21 seconds ago      Up 20 seconds                           epic_leavitt\n\n$ docker export 2c924241399c >! debian.tar\n\n$ mkdir images/debian\n\n$ tar -xf debian.tar -C images/debian/\n\n$ sudo ./diyc my1 debian bash\n\n> root@my1:/# exit\n  exit",
            "title": "Example to get a container running"
        }
    ]
}